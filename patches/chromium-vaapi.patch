Index: Mesa.spec
===================================================================
--- Mesa.spec	(revision 488)
+++ Mesa.spec	(working copy)
@@ -146,6 +146,8 @@
 Patch100:       U_fix-mpeg1_2-decode-mesa-20.2.patch
 Patch200:       u_fix-build-on-ppc64le.patch
 Patch400:       n_stop-iris-flicker.patch
+Patch10000:     chromium-vaapi-gbm-allow-gbm-allocation-of-yuv-surfaces.patch
+Patch10001:     chromium-vaapi-frontends-va-export-one-descriptor-for-contiguous-planes.patch
 %ifarch %{ix86} x86_64
 BuildRequires:  DirectX-Headers
 %endif
@@ -781,6 +783,8 @@
 %patch100 -p1
 #%patch200 -p1
 %patch400 -p1
+%patch10000 -p1
+%patch10001 -p1
 
 # Remove requires to vulkan libs from baselibs.conf on platforms
 # where vulkan build is disabled; ugly ...
Index: chromium-vaapi-frontends-va-export-one-descriptor-for-contiguous-planes.patch
===================================================================
--- chromium-vaapi-frontends-va-export-one-descriptor-for-contiguous-planes.patch	(revision 0)
+++ chromium-vaapi-frontends-va-export-one-descriptor-for-contiguous-planes.patch	(revision 0)
@@ -0,0 +1,104 @@
+Index: mesa-23.2.1/src/gallium/frontends/va/surface.c
+===================================================================
+--- mesa-23.2.1.orig/src/gallium/frontends/va/surface.c
++++ mesa-23.2.1/src/gallium/frontends/va/surface.c
+@@ -1610,8 +1610,14 @@ vlVaExportSurfaceHandle(VADriverContextP ctx,
+ #else
+    VADRMPRIMESurfaceDescriptor *desc = descriptor;
+    desc->fourcc = PipeFormatToVaFourcc(surf->buffer->buffer_format);
+-   desc->width  = surf->templat.width;
++   desc->width = surf->templat.width;
+    desc->height = surf->templat.height;
++   desc->num_objects = 0;
++
++   bool supports_contiguous_planes = screen->resource_get_info &&
++      screen->get_video_param(screen, PIPE_VIDEO_PROFILE_UNKNOWN,
++                              PIPE_VIDEO_ENTRYPOINT_BITSTREAM,
++                              PIPE_VIDEO_CAP_SUPPORTS_CONTIGUOUS_PLANES_MAP);
+ 
+    for (p = 0; p < ARRAY_SIZE(desc->objects); p++) {
+       struct winsys_handle whandle;
+@@ -1629,37 +1629,53 @@ vlVaExportSurfaceHandle(VADriverContextP ctx,
+          goto fail;
+       }
+ 
+-      memset(&whandle, 0, sizeof(whandle));
+-      whandle.type = WINSYS_HANDLE_TYPE_FD;
++      /* If the driver stores all planes in the same buffer, only one descriptor
++       * needs to be exported. resource_get_info is used to obtain pitch and
++       * offset for each plane. */
++      bool surface_needs_descriptor = (p == 0) || !supports_contiguous_planes;
++      if (surface_needs_descriptor) {
++         memset(&whandle, 0, sizeof(whandle));
++         whandle.type = WINSYS_HANDLE_TYPE_FD;
++
++         if (!screen->resource_get_handle(screen, drv->pipe, resource,
++                                          &whandle, usage)) {
++            ret = VA_STATUS_ERROR_INVALID_SURFACE;
++            goto fail;
++         }
+ 
+-      if (!screen->resource_get_handle(screen, drv->pipe, resource,
+-                                       &whandle, usage)) {
+-         ret = VA_STATUS_ERROR_INVALID_SURFACE;
+-         goto fail;
+-      }
++         desc->objects[p].fd = (int)whandle.handle;
++         desc->num_objects++;
+ 
+-      desc->objects[p].fd   = (int)whandle.handle;
+-      /* As per VADRMPRIMESurfaceDescriptor documentation, size must be the
+-       * "Total size of this object (may include regions which are not part
+-       * of the surface)."" */
+-      desc->objects[p].size = (uint32_t) whandle.size;
+-      desc->objects[p].drm_format_modifier = whandle.modifier;
++         /* As per VADRMPRIMESurfaceDescriptor documentation, size must be the
++         * "Total size of this object (may include regions which are not part
++         * of the surface)."" */
++         desc->objects[p].size = (uint32_t) whandle.size;
++         desc->objects[p].drm_format_modifier = whandle.modifier;
++      }
+ 
+       if (flags & VA_EXPORT_SURFACE_COMPOSED_LAYERS) {
+-         desc->layers[0].object_index[p] = p;
+-         desc->layers[0].offset[p]       = whandle.offset;
+-         desc->layers[0].pitch[p]        = whandle.stride;
++         desc->layers[0].object_index[p] = desc->num_objects - 1;
++
++         if (supports_contiguous_planes) {
++            screen->resource_get_info(screen, resource, &desc->layers[0].pitch[p], &desc->layers[0].offset[p]);
++         } else {
++            desc->layers[0].pitch[p] = whandle.stride;
++            desc->layers[0].offset[p] = whandle.offset;
++         }
+       } else {
+          desc->layers[p].drm_format      = drm_format;
+          desc->layers[p].num_planes      = 1;
+-         desc->layers[p].object_index[0] = p;
+-         desc->layers[p].offset[0]       = whandle.offset;
+-         desc->layers[p].pitch[0]        = whandle.stride;
++         desc->layers[p].object_index[0] = desc->num_objects - 1;
++
++         if (supports_contiguous_planes) {
++            screen->resource_get_info(screen, resource, &desc->layers[p].pitch[0], &desc->layers[p].offset[0]);
++         } else {
++            desc->layers[p].pitch[0] = whandle.stride;
++            desc->layers[p].offset[0] = whandle.offset;
++         }
+       }
+    }
+ 
+-   desc->num_objects = p;
+-
+    if (flags & VA_EXPORT_SURFACE_COMPOSED_LAYERS) {
+       uint32_t drm_format = pipe_format_to_drm_format(surf->buffer->buffer_format);
+       if (drm_format == DRM_FORMAT_INVALID) {
+@@ -1699,7 +1721,7 @@ vlVaExportSurfaceHandle(VADriverContextP ctx,
+ 
+ fail:
+ #ifndef _WIN32
+-   for (i = 0; i < p; i++)
++   for (i = 0; i < desc->num_objects; i++)
+       close(desc->objects[i].fd);
+ #else
+    if(whandle.handle)
Index: chromium-vaapi-gbm-allow-gbm-allocation-of-yuv-surfaces.patch
===================================================================
--- chromium-vaapi-gbm-allow-gbm-allocation-of-yuv-surfaces.patch	(revision 0)
+++ chromium-vaapi-gbm-allow-gbm-allocation-of-yuv-surfaces.patch	(revision 0)
@@ -0,0 +1,123 @@
+Index: mesa-23.2.1/src/egl/drivers/dri2/platform_drm.c
+===================================================================
+--- mesa-23.2.1.orig/src/egl/drivers/dri2/platform_drm.c
++++ mesa-23.2.1/src/egl/drivers/dri2/platform_drm.c
+@@ -117,6 +117,9 @@ dri2_drm_config_is_compatible(struct dri2_egl_display *dri2_dpy,
+          break;
+    }
+ 
++   if (visual->is_yuv)
++      return false;
++
+    if (i == dri2_dpy->gbm_dri->num_visuals)
+       return false;
+ 
+@@ -631,6 +634,9 @@ drm_add_configs_for_visuals(_EGLDisplay *disp)
+       for (unsigned j = 0; j < num_visuals; j++) {
+          struct dri2_egl_config *dri2_conf;
+ 
++         if (visuals[j].is_yuv)
++            continue;
++
+          if (visuals[j].rgba_shifts.red != shifts[0] ||
+              visuals[j].rgba_shifts.green != shifts[1] ||
+              visuals[j].rgba_shifts.blue != shifts[2] ||
+Index: mesa-23.2.1/src/gbm/backends/dri/gbm_dri.c
+===================================================================
+--- mesa-23.2.1.orig/src/gbm/backends/dri/gbm_dri.c
++++ mesa-23.2.1/src/gbm/backends/dri/gbm_dri.c
+@@ -522,6 +522,82 @@ static const struct gbm_dri_visual gbm_dri_visuals_table[] = {
+      { 16, 16, 16, 16 },
+      true,
+    },
++   {
++     GBM_FORMAT_YUYV, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YVYU, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_UYVY, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_VYUY, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_AYUV, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_NV12, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_NV21, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_NV16, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_NV61, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YUV410, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YVU410, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YUV411, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YVU411, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YUV420, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YVU420, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YUV422, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YVU422, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YUV444, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
++   {
++     GBM_FORMAT_YVU444, __DRI_IMAGE_FORMAT_NONE,
++     .is_yuv = true,
++   },
+ };
+ 
+ static int
+Index: mesa-23.2.1/src/gbm/backends/dri/gbm_driint.h
+===================================================================
+--- mesa-23.2.1.orig/src/gbm/backends/dri/gbm_driint.h
++++ mesa-23.2.1/src/gbm/backends/dri/gbm_driint.h
+@@ -58,6 +58,7 @@ struct gbm_dri_visual {
+       unsigned int alpha;
+    } rgba_sizes;
+    bool is_float;
++   bool is_yuv;
+ };
+ 
+ struct gbm_dri_device {
